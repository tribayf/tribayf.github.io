<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Begin Jekyll SEO tag v2.3.0 -->
<title>Exploring C++ Part 1: std::lower_bound | Tristan Bayfield</title>
<meta property="og:title" content="Exploring C++ Part 1: std::lower_bound" />
<meta name="author" content="Tristan Bayfield" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction" />
<meta property="og:description" content="Introduction" />
<link rel="canonical" href="https://tribayf.github.io/blog/2018/01/std-lower-bound" />
<meta property="og:url" content="https://tribayf.github.io/blog/2018/01/std-lower-bound" />
<meta property="og:site_name" content="Tristan Bayfield" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-01-25T00:00:00-08:00" />
<script type="application/ld+json">
{"publisher":null,"author":{"@type":"Person","name":"Tristan Bayfield"},"url":"https://tribayf.github.io/blog/2018/01/std-lower-bound","description":"Introduction","headline":"Exploring C++ Part 1: std::lower_bound","dateModified":"2018-01-25T00:00:00-08:00","datePublished":"2018-01-25T00:00:00-08:00","name":null,"sameAs":null,"@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://tribayf.github.io/blog/2018/01/std-lower-bound"},"image":null,"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/flexslider.css">
  <link rel="stylesheet" href="/css/swipebox.css">
  <link rel="icon" type="image/png" href="https://tribayf.github.io/assets/img/site/t.png"><script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": {
      matchFontHeight: true,
      scale: 90
    },
    TeX: {
      equationNumbers: {
        autoNumber: "AMS"
      }
    },
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true,
    }
  });
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

  <body>
    <header class="site-header">
  <div class="wrapper">
    <a class="site-title" href="/">Tristan Bayfield</a>
    <nav class="site-nav">
  <a href="#" class="menu-icon">
    <svg viewBox="0 0 18 15">
      <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
      <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
      <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
    </svg>
  </a>
  <div class="trigger">
    
    
    <a class="nav-link " href="/about">About Me</a>
    
    <a class="nav-link " href="/blog">Blog</a>
    
    <a class="nav-link " href="/portfolio">Portfolio</a>
    
  </div>
</nav>

  </div>
</header>

    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Exploring C++ Part 1: std::lower_bound</h1>
    <h2 class="post-date post-meta"><time datetime="2018-01-25T00:00:00-08:00" itemprop="datePublished">Jan 25, 2018</time></h2>
  </header>
  <div class="post-content" itemprop="articleBody">
    <h2 id="introduction">Introduction</h2>

<p>Binary search is one of the most widely used, and arguably most important algorithm for any programmer to know. While conceptually straightforward, it can be <a href="https://research.googleblog.com/2006/06/extra-extra-read-all-about-it-nearly.html" target="_blank">surprisingly difficult</a> to implement correctly. In addition, issues crop up in generalizing across input types. C++ provides the ability to do so through its templating system. However, in using templated algorithms, one must be careful to respect any implicit constraints on template type parameters, as failing to do so can lead to code that is hard to debug.</p>

<p>For these reasons, it can be instructive to take a closer look binary search, and why I have chosen to discuss it here (also because I’ve been watching a lot of Alexander Stepanov and Sean Parent lectures on YT lately 😅). The following considers <code class="highlighter-rouge">std::lower_bound</code>, a particular flavour of binary search included in the C++ Standard Template Library. Let’s have a look!</p>

<h2 id="description">Description</h2>

<p>One of four binary search algorithms included in the Standard Template Library (STL) since its first publication in 1994 <a href="#stepanov1995standard">[1]</a>, <code class="highlighter-rouge">std::lower_bound</code> returns the position of the first element of a sorted range that does not precede the search key.</p>

<p>The STL exposes two ways to call <code class="highlighter-rouge">std::lower_bound</code>, which I’ll call version 1 and version 2, respectively:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">I</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">I</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">I</span> <span class="n">first</span><span class="p">,</span> <span class="n">I</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
</code></pre></div></div>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">I</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Compare</span><span class="o">&gt;</span>
<span class="n">I</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">I</span> <span class="n">first</span><span class="p">,</span> <span class="n">I</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">,</span> <span class="n">Compare</span> <span class="n">cmp</span><span class="p">);</span>
</code></pre></div></div>

<p>Version 1 is a specialization of version 2, using the <em>less than</em> operator (<code class="highlighter-rouge">operator&lt;</code>) to make comparisons between <code class="highlighter-rouge">value</code> and elements of the input range <code class="highlighter-rouge">[first, last)</code>, while version 2 accepts a user-provided comparator.</p>

<p>We can see a possible implementation below, which is based on the one given by Sean Parent in <a href="#parent2016bettercode">[2]</a>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iterator&gt;
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">I</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Compare</span><span class="o">&gt;</span>
<span class="c1">// Requires ForwardIterator(I), and Compare partitions [first, last)
// with respect to the expression cmp(elem, value).
</span><span class="n">I</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">I</span> <span class="n">first</span><span class="p">,</span> <span class="n">I</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">,</span> <span class="n">Compare</span> <span class="n">cmp</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// preconditions:
</span>    <span class="c1">//   - [first, last) is a valid range
</span>    <span class="c1">// postconditions:
</span>    <span class="c1">//   - the iterator returned is in the range [first, last]
</span>    <span class="k">auto</span> <span class="n">n</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">h</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">m</span> <span class="o">=</span> <span class="n">next</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cmp</span><span class="p">(</span><span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">next</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">n</span> <span class="o">-=</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The algorithm works as per the expected behaviour of binary search: given a sorted range, it performs a comparison with the median element, discarding the half-range that does not include the search key, then continues inductively on remaining elements until termination. The value returned is an iterator pointing to the element that satisfies the search criteria, if found, otherwise <code class="highlighter-rouge">last</code>.</p>

<p>Note that the convention of using <a href="https://en.wikipedia.org/wiki/Interval_(mathematics)#Terminology" target="_blank">half-open intervals</a> to indicate ranges. Depending on whichever is more convenient, either a bounded range <code class="highlighter-rouge">[first, last)</code>, or a counted range <code class="highlighter-rouge">[first, n)</code> $\equiv$ <code class="highlighter-rouge">[first, first+n)</code>, is used. The half-open notation expresses that <code class="highlighter-rouge">last</code> $\equiv$ <code class="highlighter-rouge">first+n</code> points to the first element past the last dereferenceable element of the range (as iterators, like pointers, are dereferenced to get the value they point to). Used as a token, <code class="highlighter-rouge">last</code> safely denotes the end of a range without being required to point to valid memory, but as such, should never be dereferenced. When returned from an algorithm, <code class="highlighter-rouge">last</code> is interpreted as a negative result.</p>

<p>Another point to consider is that the C++ standard does not require that compilers implement <a href="https://en.wikipedia.org/wiki/Tail_call" target="_blank">tail-call</a> optimization. As as result, algorithms implemented in C++ tend to use loops, rather than recurrence, to avoid bottoming out the call-stack.</p>

<p>Now that we have our algorithm, we can exercise it like so:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include "lower_bound.h"
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">v</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span> <span class="p">};</span>

    <span class="k">auto</span> <span class="n">first</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">last</span>  <span class="o">=</span> <span class="n">end</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>

    <span class="c1">// extra parens disambiguate call to lower_bound
</span>    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="p">(</span><span class="n">lower_bound</span><span class="p">)(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"not found!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">it</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>which gives the result:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>7, 4
</code></pre></div></div>

<p>Here, our call to <code class="highlighter-rouge">lower_bound</code> returned an iterator pointing to the 7th element, which has a value of 4. This is indeed the first element that does not precede 4 in the range that we supplied.</p>

<p>To further illustrate the algorithm’s behaviour, suppose that we run the it again with all the 4’s of the input range changed to 5’s, and with the search key left unchanged. We would again receive an iterator pointing to the 7th element, which would still be the first element not preceding a value of 4, but it would instead have a value of 5. If we subsequently run the algorithm with a search key greater than 6, we would receive an iterator pointing to <code class="highlighter-rouge">last</code>. Such is the behaviour of <code class="highlighter-rouge">lower_bound</code>.</p>

<p>(See this <a href="/assets/img/blog/2018-01-25-std-lower-bound.png">graphic</a>{ target: _blank } for a visual demonstration of how <code class="highlighter-rouge">lower_bound</code> behaves with the first set of inputs.)</p>

<h2 id="analysis">Analysis</h2>

<h3 id="type-requirements">Type Requirements</h3>

<p>As mentioned above, C++ enables generic programming through its templating system. Templatizing an algorithm increases its applicability across a variety of input types, while introducing the extra burden on callers who must be careful to respect any implicit requirements on template type parameters. Failure to do so can lead to crashes, undefined behaviour, or cryptic compile-time errors.</p>

<p>Our case is no exception. For our algorithm to behave correctly, it is required that</p>

<ol>
  <li>Template type parameter <code class="highlighter-rouge">I</code> is a model of <a href="http://en.cppreference.com/w/cpp/concept/ForwardIterator" target="_blank"><code class="highlighter-rouge">ForwardIterator</code></a>, and</li>
  <li>The expression <code class="highlighter-rouge">element &lt; value</code> is valid for all elements of the input range (version 1) or the template type parameter <code class="highlighter-rouge">Compare</code> is a binary predicate where <code class="highlighter-rouge">cmp(element, value)</code> forms a partition of the range <code class="highlighter-rouge">[first, last)</code> (version 2).</li>
</ol>

<p>The first requirement states that <code class="highlighter-rouge">I</code> is a type of iterator with the ability to be incremented forward, without invalidating any copies made prior to incrementing (known as the <a href="http://en.cppreference.com/w/cpp/concept/ForwardIterator#Multipass_guarantee" target="_blank">multipass guarantee</a> where for instances <code class="highlighter-rouge">a</code>, <code class="highlighter-rouge">b</code> of <code class="highlighter-rouge">I</code> it is the case that <code class="highlighter-rouge">a == b</code> and <code class="highlighter-rouge">++a == ++b</code> are  when <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code> point to the same element), and that elements are both readable and writable via the iterator. For our purposes, we need only to read from instances of <code class="highlighter-rouge">I</code>.</p>

<p>As for the second requirement, up until now, I have been using <em>precedes</em> where I might have been using <em>less than</em>. This is true for version 1 of the algorithm, which actually satisfies a stricter requirement. However, all we really need is something that defines a partition on the input range, where every element that <em>precedes</em> the search key succeeds in the comparison, while every other element fails—giving us our partition. It is sufficient to use <em>precedes</em>, indicating that there is at least a <a href="https://en.wikipedia.org/wiki/Partially_ordered_set" target="_blank"><em>partial ordering</em></a> of the input range, and this holds for both versions of the algorithm. In addition, the more general, version 2 does not even require that the value-type of <code class="highlighter-rouge">I</code> be the same as <code class="highlighter-rouge">T</code>, as we’ll soon see.</p>

<p>Originally, <code class="highlighter-rouge">Compare</code> was required to define a <a href="https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings" target="_blank"><em>strict weak order</em></a> on <code class="highlighter-rouge">[first, last)</code>, but it was later pointed out that this requirement is stronger than needed <a href="#lgw270">[3]</a>. A strict weak order has that the arguments to <code class="highlighter-rouge">cmp</code> be of the same type (as in <code class="highlighter-rouge">ValueType(I) == T</code>), but the applicability of <code class="highlighter-rouge">std::lower_bound</code> can be made even greater by allowing <code class="highlighter-rouge">cmp</code> to merely define a partition. This way <code class="highlighter-rouge">cmp</code>, together with <code class="highlighter-rouge">value</code>, can be thought of as a unary predicate $p(x) \equiv cmp(x, value)$ indicating subset membership.</p>

<p>The weaker requirement enables heterogeneous comparison between <code class="highlighter-rouge">value</code> and the elements of <code class="highlighter-rouge">[first, last)</code>, where <code class="highlighter-rouge">Compare</code> is potentially overloaded on different types:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">multi_comp</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="n">X</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="n">V</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="n">Y</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">,</span> <span class="n">V</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="n">Z</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">z</span><span class="p">,</span> <span class="n">V</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
    <span class="c1">// ...
</span><span class="p">};</span>
</code></pre></div></div>

<p>A simpler example given in <a href="#lgw270">[3]</a> shows how a collection of records may be searched by defining <code class="highlighter-rouge">Compare</code> as such:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">key_comp</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="n">X</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">key</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>In general, we can always supply arguments that satisfy stricter requirements than those specified. In the above <code class="highlighter-rouge">main</code> function, for example, a vector of integers is given to <code class="highlighter-rouge">lower_bound</code>, together with an instance of <code class="highlighter-rouge">std::less&lt;int&gt;</code> (equivalent to calling version 1) and a search key of 4. Here, <code class="highlighter-rouge">std::less&lt;int&gt;</code> defines a <a href="https://en.wikipedia.org/wiki/Total_order" target="_blank"><em>total order</em></a>, in which any two elements of the range can be compared. This is sufficient but exceeds even the requirements of a strict weak order (see <a href="https://en.wikipedia.org/wiki/Order_theory" target="_blank">order theory</a> for more explanation).</p>

<h3 id="complexity">Complexity</h3>

<p>A characteristic of binary search is that it executes in at most $\lceil log_2(n) \rceil$ comparisons per execution. There is no early termination in <code class="highlighter-rouge">std::lower_bound</code>, however, which terminates in exactly $\lceil log_2(n) \rceil$ iterations. Intuitively this makes sense because the algorithm searches for the first of a potential range of matches.</p>

<p>It should also be noted that the behaviour of <a href="http://en.cppreference.com/w/cpp/iterator/next" target="_blank"><code class="highlighter-rouge">next</code></a> depends on the type of <code class="highlighter-rouge">I</code>. As stated above, <code class="highlighter-rouge">I</code> must at least satisfy the requirements of <code class="highlighter-rouge">ForwardIterator</code>. When <code class="highlighter-rouge">I</code> additionally satisfies the requirements of <a href="http://en.cppreference.com/w/cpp/concept/RandomAccessIterator" target="_blank"><code class="highlighter-rouge">RandomAccessIterator</code></a>, such as raw pointers do, <code class="highlighter-rouge">next</code> can run in constant time, otherwise it runs in linear time.</p>

<h3 id="invariants">Invariants</h3>

<p>There are two invariants that contribute to proving the algorithm will both terminate and produce a correct result:</p>

<ol>
  <li>
    <p>The value of <code class="highlighter-rouge">n</code> is nonnegative and strictly decreasing.</p>

    <p><strong>Proof</strong>: Given the range <code class="highlighter-rouge">[first, last)</code> is initially valid, <code class="highlighter-rouge">n</code> is initialized to the nonnegative value $distance(first, last) \equiv last - first$. In each iteration of the while-loop, <code class="highlighter-rouge">n</code> is reduced by either $h = \lfloor n/2 \rfloor$ or $h + 1 = \lfloor n/2 \rfloor + 1$, but is not modified in any other way, so its value is strictly decreasing. Next, assume that in some iteration $i$, <code class="highlighter-rouge">n</code> is taken to a negative value. The most that <code class="highlighter-rouge">n</code> can can be reduced, in any iteration, is by half plus one. Thus we have that, at the start of the $(i+1)th$ iteration, $n_{i+1} = n_{i} - \lfloor n_{i}/2 \rfloor - 1 &lt; 0 \Leftrightarrow n_{i} &lt; 0$, which is a contradiction (recalling that $n_i$ cannot be zero because the loop would have terminated before starting another iteration). That is, <code class="highlighter-rouge">n</code> can only be made <em>more</em> negative, when it was <em>already</em> negative to begin with, which necessarily means that the algorithm was supplied with an invalid range. $\Box$</p>
  </li>
  <li>
    <p>The subrange <code class="highlighter-rouge">[first, n)</code> is valid as per the expected behaviour of a binary search algorithm.</p>

    <p><strong>Proof</strong>: Following from the first invariant, the length of the range <code class="highlighter-rouge">[first, n)</code> cannot exceed the length of the initial range <code class="highlighter-rouge">[first, last)</code>, or become negative. In each iteration, the median element at position $m = first + h = first + \lfloor n/2 \rfloor$ is chosen for the comparison with <code class="highlighter-rouge">value</code>. In the case that the comparison fails, the value of <code class="highlighter-rouge">n</code> is reduced by $\lfloor n/2 \rfloor$, selecting the left subrange. Conversely, when the comparison succeeds, <code class="highlighter-rouge">first</code> is moved to the right of <code class="highlighter-rouge">m</code> by one place, and <code class="highlighter-rouge">n</code> is reduced by $\lfloor n/2 \rfloor + 1$, selecting the right subrange. (Note that in either case <code class="highlighter-rouge">m</code> is excluded from the new subrange, as it has already been compared against.) The process proceeds inductively, until <code class="highlighter-rouge">n</code> is reduced to zero and the loop is exited. Thus <code class="highlighter-rouge">[first, n)</code> is valid as per the expected behaviour of binary search. $\Box$</p>
  </li>
</ol>

<h3 id="termination">Termination</h3>

<p>Termination follows from the first invariant. In each iteration, <code class="highlighter-rouge">n</code> is reduced by at most $h + 1 = \lfloor n/2 \rfloor + 1$. It is then by the integer division of <code class="highlighter-rouge">n</code> that it is guaranteed to eventually reach a value of zero, causing the loop to terminate (i.e. no such guarantee holds when <code class="highlighter-rouge">n</code> stores a floating-point value).</p>

<h3 id="correctness">Correctness</h3>

<p>To show correctness, it needs to be shown that, upon termination, <code class="highlighter-rouge">first</code> will either point to the first element that <em>does not precede</em> (<em>is not less than</em>) <code class="highlighter-rouge">value</code>, or <code class="highlighter-rouge">last</code>. Assuming valid input arguments, the correctness of the algorithm follows from the second invariant.</p>

<p>For any iteration, the right subrange is selected when <code class="highlighter-rouge">*m</code> <em>precedes</em> (<em>is less than</em>) <code class="highlighter-rouge">value</code> (i.e. the comparison succeeds). In this case, the position of <code class="highlighter-rouge">first</code> is moved to the right of <code class="highlighter-rouge">m</code> by one place because we know that all values up to and including <code class="highlighter-rouge">m</code> can be discarded. Whether the new element pointed to by <code class="highlighter-rouge">first</code> precedes <code class="highlighter-rouge">value</code>, however, remains to be shown in a subsequent iteration. We may also say that when this case is true in one or more iterations, there is at least one element of the range that precedes <code class="highlighter-rouge">value</code>.</p>

<p>Conversely, the left subrange is selected when <code class="highlighter-rouge">*m</code> <em>does not precede</em> (<em>is not less than</em>) <code class="highlighter-rouge">value</code> (i.e. the comparison fails). In this case, the position of <code class="highlighter-rouge">first</code> remains unchanged, but because we know that all elements from <code class="highlighter-rouge">m</code> onward do not precede <code class="highlighter-rouge">value</code>, they can be discarded. We may also say that when this case is true in one or more iterations, it cannot be that <code class="highlighter-rouge">first</code> equals <code class="highlighter-rouge">last</code> upon termination—that is, the algorithm will not return a negative result.</p>

<p>Thus, <code class="highlighter-rouge">first</code> moves right only when it is known that all elements up to and including <code class="highlighter-rouge">*m</code> precede <code class="highlighter-rouge">value</code>. By induction we can infer that, upon termination, <code class="highlighter-rouge">first</code> will point to either first element that <em>does not precede</em> <code class="highlighter-rouge">value</code>, or <code class="highlighter-rouge">last</code>. We can also note the two extreme cases in which <code class="highlighter-rouge">first</code> remains unchanged for the duration of the algorithm (no element preceded <code class="highlighter-rouge">value</code>), and <code class="highlighter-rouge">first</code> equals <code class="highlighter-rouge">last</code> upon termination (all elements preceded <code class="highlighter-rouge">value</code>).</p>

<h3 id="subtle-pitfalls">Subtle Pitfalls</h3>

<p>We have so far looked at the issues regarding requirements on template type parameters, but we have yet to discuss two more rather innocuous places wherein it is easy to introduce bugs.</p>

<p>First is a subtlety in our book keeping with respect to discarding elements after each comparison. For any iteration, we can consider that <code class="highlighter-rouge">[first, n) = [first, m)</code> $\cup$ <code class="highlighter-rouge">[m, n)</code> is the union of two halves about the median element <code class="highlighter-rouge">m</code>. We must be sure to discard <code class="highlighter-rouge">m</code> after each comparison, not only because it has already been compared against, but because failing to do so can result in a failure to terminate. Consider the scenario where <code class="highlighter-rouge">n = 1</code> and the comparison succeeds. Here, we would subtract <code class="highlighter-rouge">h = 0</code> from <code class="highlighter-rouge">n</code> (as opposed to <code class="highlighter-rouge">h + 1 = 1</code>), reflecting that <code class="highlighter-rouge">m</code> was not discarded. This produces an infinite loop, as <code class="highlighter-rouge">n</code> would never reach zero. Discarding <code class="highlighter-rouge">m</code> ensures that this problem is avoided.</p>

<p>Finally, some implementations might have <code class="highlighter-rouge">n</code> set by <code class="highlighter-rouge">(first + last)/2</code>. The problem here is that <code class="highlighter-rouge">first + last</code> can potentially lead to integer overflow when the input range is large. A correct implementation has <code class="highlighter-rouge">n</code> equivalently set by <code class="highlighter-rouge">(last - first)/2</code>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>In this post I discussed the issues regarding implementing and using <code class="highlighter-rouge">std::lower_bound</code> in C++. Users of templated code must be careful to respect constraints on template type parameters. Further, the nature of working with C++ requires that close attention be paid to book keeping. All of this contributes to avoiding potentially hard to find bugs. C++ is known as a dangerous language because it affords programmers the freedom to perpetrate all manor of heinous atrocities. The corollary to this, however, is that C++ programmers also have the ability to generate code that is fast and efficient—and safe, so long as sufficient care is taken.</p>

<p>I tried my best to make the information herein correct, and understandable for most people with some knowledge in computer programming. If you have any questions or feedback, please feel free to post a comment below. And thanks for reading!</p>

<h2 id="references">References</h2>
<table class="bibliography">
<tr>
  
  
  
  <th>[1]</th>
  <td>
<p><span id="stepanov1995standard">A. Stepanov and M. Lee, <i>The standard template library</i>. Hewlett Packard Laboratories 1501 Page Mill Road, Palo Alto, CA 94304, 1995. </span></p>
</td>

</tr>
<tr>
  
  
  
  <th>[2]</th>
  <td>
<p><span id="parent2016bettercode">S. Parent, “Better Code.” code::dive 2016 [Online]. Available at: <a href="https://youtu.be/cK_kftBNgBc" target="_blank">https://youtu.be/cK_kftBNgBc</a></span></p>
</td>

</tr>
<tr>
  
  
  
  <th>[3]</th>
  <td>
<p><span id="lgw270">M. Austern, “LWG Issue 270. Binary search requirements overly strict.” [Online]. Available at: <a href="https://cplusplus.github.io/LWG/issue270" target="_blank">https://cplusplus.github.io/LWG/issue270</a></span></p>
</td>

</tr>
</table>

  </div>
</article>


<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
 */
var disqus_config = function () {
    this.page.url = https://tribayf.github.io/blog/2018/01/std-lower-bound;
    this.page.identifier = /blog/2018/01/std-lower-bound;
};

(function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = 'https://tribayf-github-io.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" target="_blank">comments powered by Disqus.</a>
</noscript>
<script id="dsq-count-scr" src="//tribayf-github-io.disqus.com/count.js" async></script>


      </div>
    </div>
    <footer class="site-footer">
  <div class="wrapper">
    <h3>Contact Me</h3>
    <div class="contact-list">
      <div class="contact em">
        tristan&#x2e;bayfield&#064;sfu&#x2e;ca
      </div>
      <div class="contact github">
        <a href="https://github.com/tribayf" target="_blank"><span class="icon"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z" /></svg>
</span><span class="username">tribayf</span></a>

      </div>
      <div class="contact bitbucket">
        <a href="https://bitbucket.org/tribayf" target="_blank"><span class="icon"><svg viewBox="0 0 16 16"><path style="fill:#828282" d="M 9.0676903,7.6402263 Q 9.1447837,8.2402515 8.5807765,8.6021699 8.0167106,8.964098 7.5056867,8.6593077 7.1296494,8.4974009 6.9898409,8.1069039 6.8500324,7.7164069 6.9849323,7.3259098 7.1199188,6.9354225 7.4863121,6.773506 7.8334273,6.602073 8.1853644,6.6592206 q 0.3519275,0.057138 0.6170883,0.3381029 0.265151,0.280965 0.265151,0.6428931 z M 10.137958,7.4402147 Q 10.002971,6.4211235 9.0484122,5.8782362 8.0938528,5.3353586 7.1489373,5.7544246 6.5414834,6.0211003 6.179912,6.5973196 5.8183309,7.173539 5.8472628,7.8307117 5.8858585,8.6974126 6.5945156,9.3069641 7.3032021,9.9165151 8.190273,9.8403251 9.0676903,9.7641731 9.6558564,9.0402882 10.244022,8.3164417 10.137958,7.4402147 Z M 12.442402,2.2780758 Q 12.249561,2.0209166 11.902446,1.8542467 11.555331,1.6875671 11.343212,1.6447089 11.131083,1.6018312 10.658626,1.5256604 7.8528019,1.0780157 5.2012426,1.544674 4.7866391,1.6113187 4.5648763,1.6589691 4.3431036,1.7066002 4.0345644,1.8684972 3.7260154,2.0304137 3.5524627,2.2780467 q 0.289261,0.2666757 0.7327965,0.4333456 0.4435258,0.1666796 0.7086866,0.2095378 0.265151,0.042878 0.843673,0.109532 2.1983798,0.2762019 4.3196182,0.0097 0.607454,-0.076151 0.86296,-0.1142855 0.255517,-0.038124 0.699053,-0.2047747 0.443526,-0.1666699 0.723152,-0.4428718 z m 0.54959,9.8575902 q -0.07709,0.247633 -0.149452,0.72861 -0.07228,0.480976 -0.134986,0.800037 -0.06266,0.31906 -0.274796,0.666699 -0.212129,0.347629 -0.559244,0.538114 -0.829207,0.457171 -1.827154,0.680988 Q 9.0484122,15.773932 8.0986747,15.759642 7.1489373,15.745382 6.155802,15.583446 5.7122763,15.507295 5.3699831,15.412013 5.02769,15.316751 4.6323646,15.154854 4.2370491,14.992947 3.9285001,14.740551 3.6199609,14.488155 3.4271202,14.154806 3.1860693,13.240484 2.8775203,11.373725 l 0.057844,-0.152381 0.1735527,-0.08576 q 2.1501696,1.409588 4.8836832,1.409588 2.7335138,0 4.8933178,-1.409588 0.202484,0.05714 0.231407,0.219054 0.02897,0.161907 -0.04822,0.428592 -0.07709,0.266676 -0.07709,0.352392 z m 1.7452,-9.1527961 Q 14.486507,4.573417 13.666934,9.2212475 13.618714,9.5069761 13.406596,9.7546081 13.194477,10.002241 12.98717,10.135579 12.779864,10.268917 12.46168,10.430833 10.031893,11.630884 6.5800495,11.268965 4.1888389,11.011806 2.7811,9.9450941 2.6364696,9.8307991 2.5352272,9.6926981 2.4339849,9.5545971 2.3713185,9.3593481 2.3086619,9.1640999 2.2845029,9.0355251 2.260442,8.9069504 2.2266589,8.6593174 2.1928757,8.4116844 2.1736264,8.325968 2.0868108,7.8497544 1.9181095,6.8973371 1.7493788,5.94491 1.6481365,5.3591644 1.5468942,4.7734286 1.4215516,3.9543397 1.2961993,3.1352505 1.209423,2.4495088 1.2382965,2.2018758 1.3781635,1.9875846 1.517972,1.7732836 1.6818807,1.6304196 1.8457992,1.4875555 2.1157722,1.3446915 2.3857452,1.2018274 2.5593077,1.1304002 2.7328604,1.0590021 3.0221214,0.9542041 4.2273757,0.5160857 6.0400741,0.3446527 q 3.6543188,-0.35240185 6.5179979,0.4762136 1.494515,0.4381087 2.073036,1.1619552 0.154265,0.1904854 0.159087,0.4857397 0.0049,0.2952446 -0.05303,0.5143087 z" /></svg>
</span><span class="username">tribayf</span></a>

      </div>
      <div class="contact twitter">
        <a href="https://twitter.com/tribayf" target="_blank"><span class="icon"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z" /></svg>
</span><span class="username">tribayf</span></a>

      </div>
    </div>
  </div>
</footer><div id="disqus_thread"></div>
<script>
/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
 */

// var disqus_config = function () {
//     this.page.url = https://tribayf.github.io/blog/2018/01/std-lower-bound;
//     this.page.identifier = /blog/2018/01/std-lower-bound;
// };

(function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = 'https://tribayf-github-io.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<script id="dsq-count-scr" src="https://tribayf-github-io.disqus.com/count.js" async></script>


    
  </body>
</html>
